import numpy as np
from multi_power import MultiPower
from multi_cheb import MultiCheb
from groebner_class import Groebner
import itertools

'''
This class represents the ring A = C[x_1,...,x_n]/I as a vector space over C,
and contains the tools necessary to find the points of the variety of the
ideal generated by the given Groebner basis.
'''
class RootFinder(object):
    '''
    attributes
    ----------
    self.Groebner : Groebner object
        provides methods for calculating a Groebner basis and for
        dividing a polynomial by a set of other polynomials
    self.GB : list
        polynomials in Groebner basis
    self.vectorBasis : list
        tuples representing monomials in the vector space basis
    self.vectorSpaceDimension : int
        dimension of the vector space
    self.numVars : int
        number of variables the polynomials of the ideal are in

    methods
    -------
    makeVectorBasis(self, GB)
        Calculates a basis for C[x_1,...,x_n]/I as a vector space over C
        where I is the ideal generated by GB, a Groebner basis.
    coordinateVector(self, poly)
        Calculates the coordinate vector of the given polynomial's coset in
        C[x_1,...,x_n]/I.
    operatorMatrix(self, poly)
        Calculates the matrix m_f where f is the polynomial given. The
        eigenvalues of the computed matrix are the values of f on V(I).
    '''
    def __init__(self, G):
        '''
        parameters
        ----------
        G : Groebner object or list
            groebner object that represents a Groebner Basis for the ideal
            OR
            a list of polynomials that make up a Groebner basis
        '''
        if type(G) is list:
            self.groebner = Groebner(G)
            self.GB = G
        elif type(G) is Groebner:
            self.groebner = G
            self.GB = G.solve()
        else:
            raise ValueError("Bad argument to RootFinder constructor.")

        if (len(self.GB) == 0):
            raise ValueError("Groebner basis is empty.")

        self.vectorBasis = self.makeVectorBasis(self.GB)
        self.vectorSpaceDimension = len(self.vectorBasis)
        self.numVars = len(self.GB[0].shape)

    def makeVectorBasis(self, GB):
        '''
        parameters
        ----------
        GB: list
            polynomial objects that make up a Groebner basis for the ideal

        return
        ------
        basis : list
            tuples representing the monomials in the vector space basis
        '''
        LT_G = [f.lead_term for f in GB]
        possibleVarDegrees = [range(max(tup)) for tup in zip(*LT_G)]
        possibleMonomials = itertools.product(*possibleVarDegrees)
        basis = []

        for mon in possibleMonomials:
            divisible = False
            for LT in LT_G:
                if (self._divides(LT, mon)):
                     divisible = True
                     break
            if (not divisible):
                basis.append(mon)

        return basis

    def operatorMatrix(self, poly):
        '''
        Finds the matrix of the linear operator m_f on A = C[x_1,...,x_n]/I
        where f is the polynomial argument. The linear operator m_f is defined
        as m_f([g]) = [f]*[g] where [f] represents the coset of f in
        A. Since m_f is a linear operator on A, it can be represented by its
        matrix with respect to the vector space basis.

        parameters
        ----------
        poly : polynomial object
            The polynomial f for which to find the matrix m_f.

        return
        ------
        multOperatorMatrix : square numpy array
            The matrix m_f
        '''

        # Reshape poly's coefficienet matrix if it is not in the same number
        # of variables as the polynomials in the Groebner basis.
        # (i.e. len(shape) is the number of variables the polynomial is in)
        polyVars = len(poly.coeff.shape)
        if polyVars != self.numVars:
            new_shape = [i for i in poly.coeff.shape]
            for j in range(self.numVars-polyVars): new_shape.append(1)
            if type(poly) is MultiPower:
                poly = MultiPower(poly.coeff.reshape(tuple(new_shape)))
            if type(poly) is MultiCheb:
                poly = MultiCheb(poly.coeff.reshape(tuple(new_shape)))

        dim = self.vectorSpaceDimension
        operatorMatrix = np.zeros((dim, dim))

        for i in range(dim):
            monomial = self.vectorBasis[i]
            poly_ = poly.mon_mult(monomial)

            operatorMatrix[:,i] = self.coordinateVector(poly_)

        return operatorMatrix

    def coordinateVector(self, poly):
        '''
        parameters
        ----------
        reducedPoly : polynomial object
            The polynomial for which to find the coordinate vector of its coset.

        return
        ------
        coordinateVector : list
            The coordinate vector of the given polynomial's coset in
            A = C[x_1,...x_n]/I as a vector space over C
        '''

        poly = self.reduce_poly(poly)

        # reverse the array since self.vectorBasis is in increasing order
        # and monomialList() gives a list in decreasing order
        poly_terms = poly.monomialList()[::-1]
        assert(len(poly_terms) <= self.vectorSpaceDimension)

        coordinateVector = [0] * self.vectorSpaceDimension
        for monomial in poly_terms:
            coordinateVector[self.vectorBasis.index(monomial)] = \
                poly.coeff[monomial]

        return coordinateVector

    def _divides(self, mon1, mon2):
        '''
        parameters
        ----------
        mon1 : tuple
            contains the exponents of the monomial divisor
        mon2 : tuple
            contains the exponents of the monomial dividend

        return
        ------
        boolean
            true if mon1 divides mon2, false otherwise
        '''
        return all(np.subtract(mon2, mon1) >= 0)

    def reduce_poly(self, poly):
        '''
        Divides a polynomial by the Groebner basis using the standard
        multivariate division algorithm and returns the remainder

        parameters
        ----------
        polynomial : polynomial object
            the polynomial to be divided by the Groebner basis

        return
        ------
        polynomial object
            the unique remainder of poly divided by self.GB
        '''
        change = True
        while change:
            change = False
            for basis_poly in self.GB:
                if basis_poly != poly and \
                self._divides(basis_poly.lead_term, poly.lead_term):

                    monomial = tuple(np.subtract(
                        poly.lead_term,basis_poly.lead_term))

                    new = basis_poly.mon_mult(monomial)

                    lcm = np.maximum(poly.coeff.shape, new.coeff.shape)

                    poly_pad = np.subtract(lcm, poly.coeff.shape)
                    poly_pad[np.where(poly_pad<0)]=0
                    pad_poly = self._pad_back(poly_pad, poly)

                    new_pad = np.subtract(lcm, new.coeff.shape)
                    new_pad[np.where(new_pad<0)]=0
                    pad_new = self._pad_back(new_pad,new)

                    new_coeff = pad_poly.coeff-(poly.lead_coeff/basis_poly.lead_coeff)*pad_new.coeff
                    new_coeff[np.where(abs(new_coeff) < 1.e-10)]=0 #Get rid of floating point errors to make more stable
                    poly.__init__(new_coeff)
                    #print(poly.coeff)
                    change = True
                    pass
                pass
            pass
        return poly

    def _pad_back(self,mon,poly):
        tuple1 = []
        for i in mon:
            list1 = (0,i)
            tuple1.append(list1)
        if type(poly) == MultiPower:
            return MultiPower(np.pad(poly.coeff, tuple1, 'constant', \
            constant_values = 0), clean_zeros = False)
        elif type(poly) == MultiCheb:
            return MultiCheb(np.pad(poly.coeff, tuple1, 'constant', \
            constant_values = 0), clean_zeros = False)
