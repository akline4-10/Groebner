import numpy as np
from multi_power import MultiPower
from multi_cheb import MultiCheb
from groebner_class import Groebner
import itertools

'''
This class represents the ring A = C[x_1,...,x_n]/I as a vector space over C,
and contains the tools necessary to find the points of the variety of the
ideal generated by the given Groebner basis.
'''
class RootFinder(object):
    '''
    attributes
    ----------
    self.Groebner : Groebner object
        provides methods for calculating a Groebner basis and for
        dividing a polynomial by a set of other polynomials
    self.GB : list
        polynomials in Groebner basis
    self.vectorBasis : list
        tuples representing monomials in the vector space basis
    self.vectorSpaceDimension : int
        dimension of the vector space
    self.numVars : int
        number of variables the polynomials of the ideal are in

    methods
    -------
    makeVectorBasis(self, GB)
        Calculates a basis for C[x_1,...,x_n]/I as a vector space over C
        where I is the ideal generated by GB, a Groebner basis.
    coordinateVector(self, poly)
        Calculates the coordinate vector of the given polynomial's coset in
        C[x_1,...,x_n]/I.
    multMatrix(self, poly)
        Calculates the matrix m_f where f is the polynomial given. The
        eigenvalues of the computed matrix are the values of f on V(I).
    '''
    def __init__(self, G):
        '''
        parameters
        ----------
        G : Groebner object or list
            groebner object that represents a Groebner Basis for the ideal
            OR
            a list of polynomials that make up a Groebner basis
        '''
        if type(G) is list:
            self.groebner = Groebner(G)
            self.GB = G
        elif type(G) is Groebner:
            self.groebner = G
            self.GB = G.solve()
        else:
            raise ValueError("Bad argument to RootFinder constructor.")

        if (len(self.GB) == 0):
            raise ValueError("Groebner basis is empty.")

        self.vectorBasis = self.makeVectorBasis(self.GB)
        self.vectorSpaceDimension = len(self.vectorBasis)
        self.numVars = len(self.GB[0].shape)

    def makeVectorBasis(self, GB):
        '''
        parameters
        ----------
        GB: list
            polynomial objects that make up a Groebner basis for the ideal

        return
        ------
        basis : list
            tuples representing the monomials in the vector space basis
        '''
        LT_G = [f.lead_term for f in GB]
        possibleVarDegrees = [range(max(tup)) for tup in zip(*LT_G)]
        possibleMonomials = itertools.product(*possibleVarDegrees)
        basis = []

        for mon in possibleMonomials:
            divisible = False
            for LT in LT_G:
                if (self._divides(LT, mon)):
                     divisible = True
                     break
            if (not divisible):
                basis.append(mon)

        return basis

    def multMatrix(self, poly):
        '''
        Finds the matrix of the linear operator m_f on A = C[x_1,...,x_n]/I
        where f is the polynomial argument. The linear operator m_f is defined
        as m_f([g]) = [f]*[g] where [f] represents the coset of f in
        A. Since m_f is a linear operator on A, it can be represented by its
        matrix with respect to the vector space basis.

        parameters
        ----------
        poly : polynomial object
            The polynomial f for which to find the matrix m_f.

        return
        ------
        multOperatorMatrix : square numpy array
            The matrix m_f
        '''

        # Reshape poly's coefficienet matrix if it is not in the same number
        # of variables as the polynomials in the Groebner basis.
        # (i.e. len(shape) is the number of variables the polynomial is in)
        polyVars = len(poly.coeff.shape)
        if polyVars != self.numVars:
            new_shape = [i for i in poly.coeff.shape]
            for j in range(self.numVars-polyVars): new_shape.append(1)
            if type(poly) is MultiPower:
                poly = MultiPower(poly.coeff.reshape(tuple(new_shape)))
            if type(poly) is MultiCheb:
                poly = MultiCheb(poly.coeff.reshape(tuple(new_shape)))

        dim = self.vectorSpaceDimension
        operatorMatrix = np.zeros((dim, dim))

        for i in range(dim):
            monomial = self.vectorBasis[i]
            poly_ = poly.mon_mult(monomial)

            operatorMatrix[:,i] = self.coordinateVector(poly_)

        return operatorMatrix

    def coordinateVector(self, poly):
        '''
        parameters
        ----------
        reducedPoly : polynomial object
            The polynomial for which to find the coordinate vector of its coset.

        return
        ------
        coordinateVector : list
            The coordinate vector of the given polynomial's coset in
            A = C[x_1,...x_n]/I as a vector space over C
        '''

        poly = self.reduce_poly(poly)

        # reverse the array since self.vectorBasis is in increasing order
        # and monomialList() gives a list in decreasing order
        poly_terms = poly.monomialList()
        assert(len(poly_terms) <= self.vectorSpaceDimension)

        coordinateVector = [0] * self.vectorSpaceDimension
        for monomial in poly_terms:
            coordinateVector[self.vectorBasis.index(monomial)] = \
                poly.coeff[monomial]

        return coordinateVector

    def _divides(self, mon1, mon2):
        '''
        parameters
        ----------
        mon1 : tuple
            contains the exponents of the monomial divisor
        mon2 : tuple
            contains the exponents of the monomial dividend

        return
        ------
        boolean
            true if mon1 divides mon2, false otherwise
        '''
        return all(np.subtract(mon2, mon1) >= 0)

    def reduce_poly(self, poly, basis=None):
        '''
        Divides a polynomial by the Groebner basis using the standard
        multivariate division algorithm and returns the remainder

        parameters
        ----------
        polynomial : polynomial object
            the polynomial to be divided by the Groebner basis

        return
        ------
        polynomial object
            the unique remainder of poly divided by self.GB
        '''
        if (basis is None):
            basis = self.GB

        remainder_coeff = np.zeros_like(poly.coeff, dtype=float)

        # while poly is not the zero polynomial
        while np.any(poly.coeff):
            divisible = False
            # Go through polynomials in Groebner basis
            for basis_poly in basis:
                # If the LT of the polynomial in the Groebner basis divides
                # the LT of poly
                if self._divides(basis_poly.lead_term, poly.lead_term):
                    # Get the quotient LT(poly)/LT(basis_poly)
                    LT_quotient = tuple(np.subtract(
                        poly.lead_term,basis_poly.lead_term))

                    new = basis_poly.mon_mult(LT_quotient)

                    # Get max value of shapes to know how much to pad
                    max_shape = np.maximum(poly.coeff.shape, new.coeff.shape)

                    poly_pad = np.subtract(max_shape, poly.coeff.shape)
                    poly.__init__(self.pad_matrix(poly_pad, poly.coeff), clean_zeros=False)

                    new_pad = np.subtract(max_shape, new.coeff.shape)
                    new.__init__(self.pad_matrix(new_pad, new.coeff), clean_zeros=False)

                    new_coeff = poly.coeff - \
                        (poly.lead_coeff/basis_poly.lead_coeff)*new.coeff
                    new_coeff[np.where(abs(new_coeff) < 1.e-10)]=0
                    poly.__init__(new_coeff, clean_zeros=False)

                    print("poly:\n", poly.coeff)

                    divisible = True
                    break

            if not divisible:
                lcm = np.maximum(poly.coeff.shape, remainder_coeff.shape)
                remainder_pad = np.subtract(lcm, remainder_coeff.shape)
                remainder_coeff = \
                    self.pad_matrix(remainder_pad, remainder_coeff)

                # Add lead term to remainder
                polyLT = poly.lead_term
                remainder_coeff[polyLT] = poly.coeff[polyLT]

                # Subtract LT from poly
                new_coeff = poly.coeff
                new_coeff[poly.lead_term] = 0
                poly.__init__(new_coeff)

        if (type(poly) == MultiPower):
            return MultiPower(remainder_coeff)
        else:
            return MultiCheb(remainder_coeff)

    def pad_matrix(self, pad, matrix):
        _list = []
        for i in pad:
            _tuple = (0,i)
            _list.append(_tuple)
        return np.pad(matrix, _list, 'constant', constant_values=0)
